# Шаблоны

Шаблоны (также называют *обощениями*, *обобщёнными типами*, *универсальными шаблонами*) — мощное средство, позволяющее писать универсальные классы, интерфейсы, методы, массивы, делегаты и т.д., работающие с несколькими типами данных.

## Проблема до появления шаблонов

Сначала давайте рассмотрим проблему, вставшую перед разработчиками языка C#, которя привела их к добавлению данного средства в язык (шаблоны впервые появились в .NET 2.0):

Пусть есть класс `Account`, определяющий аккаунт пользователя некой социальной сети:

```csharp
class Account
{
    public int Id { get; set; }
    public string Firstname { get; set; }
    public string Lastname { get; set; }

    public Account(int id, string firstname, string lastname)
    {
        Id = id;
        Firstname = firstname;
        Lastname = lastname;
    }
}
```

Создадим объект этого класса, т.е. создадим аккаунт:

```csharp
Account firstAccount = new Account(1, "Thomas", "Brooks");
```

Но резко мы решили поменять архитектуру аккаунтов и сделать так, что бы уникальные идентификаторы `Id` могли быть строковыми. Что делать? Переписывать класс? Если и так, то как его переписывать? Мы бы могли изменить тип поля `Id` на `object`, действительно, ведь все типы данных в C# наследуются от `Object`:

```csharp
Account firstAccount = new Account("thom", "Thomas", "Brooks");

class Account
{
    public object Id { get; set; }
    public string Firstname { get; set; }
    public string Lastname { get; set; }

    public Account(object id, string firstname, string lastname)
    {
        Id = id;
        Firstname = firstname;
        Lastname = lastname;
    }
}
```

Теперь `Id` является `object` и туда можно записывать любые данные от примитивных типов до пользовательских. Проблема решена, мы можем присваивать строковые уникальные идентификаторы `Id`. Всё работает, правда, теперь нужно производить явное приведение типов для получения строки из поля `Id`:

```csharp
string userId = (string)firstAccount.Id;
```

Ну и стоит сказать, что вариант с `object` крайне неоптимален и не является безопасным. Его неоптимальность заключается в том, что при сохранении примитива в переменную типа `object`, происходит *упаковка* (*boxing*), а при получении данных обратно в переменную примитивного типа, происходит *распаковка* (*unboxing*). Рассмотрим, что такое *упаковка* и *распаковка* на примерах:

 - При присвоении полю `Id` значения типа `string`, происходит *упаковка* этого значения в тип `Object`.
 - При получении значения поля `Id` в виде `string`, происходит *распаковка* этого значения в тип `string` из типа `Object`.

Упаковка (*boxing*) предполагает преобразование объекта значимого (примитивного) типа к типу `object`. При упаковке среда CLR обёртывает значение в объект типа `System.Object` и сохраняет его в *управляемой куче* (*heap*) Распаковка (*unboxing*) же предполагает преобразование объекта типа `object` к значимому типу. Упаковка и распаковка занимают время, поэтому ведут к снижению производительности.

Также было сказано, что вариант с `object` небезопасен, это можно показать на примере:

```csharp
Account firstAccount = new Account("thom", "Thomas", "Brooks"); // Id = "thom"
int userId = (int)firstAccount.Id; // Исключение InvalidCastException
```

Мы не можем точно знать, что из себя представляет объект, хранящийся в `Id`, поэтому запросто можем ошибиться и получить `InvalidCastException`.

## Решение проблемы при помощи шаблонов

В .NET 2.0 добавили шаблоны. Вот пример шаблонного метода:

```csharp
static /* static не обязателен */ string sum<T>(T value1, T value2) // метод принимает два параметра типа T
{
    return value1.ToString() + value2.ToString();
}
```

В угловых скобках сразу после имени метода указывается *обобщённый параметр*, в нашем случае это `T`, название может быть любым, просто **T** — это общепринятое название, означающее ***T**emplate*. В коде буква `T` будет заменятся на тип данных, который будет передан. Например, если мы передадим тип данных `float`, то все `T` в коде метода заменятся на `float`. 

Посмотрим, как может использоваться метод, описанный выше:

```csharp
string intsum = sum<int>(10, 20);
Console.WriteLine(intsum); // 510

string strsum = sum<string>("Hello ", "world!");
Console.WriteLine(strsum); // Hello world!
```

Сначала мы вызываем метод `sum<int>()` и везде в методе `sum<T>()` буква `T` заменится на `int`. Затем мы вызываем метод `sum<string>()`, на этот раз, параметры передаются как строки. Если попытаться в качестве параметров передать, например, числа, то произойдёт ошибка, в этом и суть шаблонов.

Давайте создадим класс поддержки универсального массива из 10 значений:

```csharp
public class UniversalArray<T>
{
    T[] array = new T[10];
    int index = 0;

    public bool Add(T value)
    {
        if (index >= 10)
        {
            return false;
        }
        array[index++] = value;
        return true;
    }

    public T Get(int index)
    {
        if (index < this.index && index >= 0)
        {
            return array[index];
        }
        else
        {
            return default(T); // функция default() возвращает значение по умолчанию для типа данных переданного параметра
        }
    }

    public int GetCount()
    {
        return index;
    }
}
```

Объект данного класса создаётся следующим образом:

```csharp
UniversalArray<int> array = new UniversalArray<int>();
```

Создадим с помощью этого класса массив из `double`, добавим туда элементов и выведем все эти элементы в консоль:

```csharp
UniversalArray<double> doubleArray = new UniversalArray<double>();

doubleArray.Add(12.5);
doubleArray.Add(11.9);
doubleArray.Add(0.78);
doubleArray.Add(2.0);

for (int i = 0; i < doubleArray.GetCount(); i++)
{
    Console.WriteLine(doubleArray.Get(i));
}
```

У нас есть уникальный класс, и если мы захотим на его основе написать массив для строк, нам не нужно будет переписывать класс, а достаточно будет изменить объявление объекта:

```csharp
UniversalArray<string> stringArray = new UniversalArray<string>();
```

## Использование нескольких обощённых параметров

Можно использовать несколько обощённых параметров (логика работы та же):

```csharp
static string sum<T, U>(T value1, U value2)
{
    return value1.ToString() + value2.ToString();
}
```

## Ограничения шаблонов

Шаблоны неопределённого типа полуются слишком универсальными (принимают любые типы данных), это нужно не всегда. Часто бывает лучше ограничиться несколькими типами данных. Это позволяет сделать ключевое слово `where`:

```csharp
public class TemplateClass<T> where T: ???
```

Здесь `???` может принимать одно из следующих значений:

 - `Class` — тогда `T` принимает только классы (класс не должен быть `sealed`, иначе его использование не имеет смысла).
 - `struct` — тогда `T` принимает только структуры.
 - `new()` — тогда `T` принимает только классы, имеющие конструктор по умолчанию.
 - `Имя_класса` — тогда `T` принимает только класс `Имя_класса` и его наследников.
 - `Имя_интерфейса` — тогда `T` принимает только классы, реализующие интерфейс `Имя_интерфейса`.

### Ограничения шаблонов с несколькими универсальными параметрами

```csharp
class TemplateClass<T, U>
    where T: ???
    where U: ???
{
// ...
}
```